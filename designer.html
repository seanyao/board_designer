<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>Board designer</title>
<style>
    html,body{height:100%;margin:0;background:#f5f5f5;
              display:flex;justify-content:center;align-items:center;font-family:Arial,Helvetica,sans-serif;}
    .wrapper{position:relative}
    .canvas{
        position:relative;
        width:17cm;
        height:17cm;
        border:2px solid #000;
        background:#fff;
        background-image:
            linear-gradient(#ddd 1px,transparent 1px),
            linear-gradient(90deg,#ddd 1px,transparent 1px);
        background-size:5mm 5mm;
        overflow:hidden;
    }
    /* 单组孔位容器 */
    .hole-group{position:absolute;top:0;left:0;cursor:move}
    /* M3 孔位：外径6 mm 圆环+中心文字 */
    .m3-hole{
        position:absolute;
        width:6mm;
        height:6mm;
        border-radius:50%;
        transform:translate(-50%,-50%);
        user-select:none;
        display:flex;
        align-items:center;
        justify-content:center;
        font-size:7px;
        font-weight:bold;
        color:#fff;
        z-index:10;
    }
    /* 虚线边 */
    .edge{
        position:absolute;
        pointer-events:none;
        border-top:1px dashed;
        transform-origin:left top;
    }
    /* 边长标签 */
    .edge-label{
        position:absolute;
        font-size:10px;
        background:rgba(0,0,0,.7);
        color:#fff;
        padding:1px 3px;
        border-radius:2px;
        pointer-events:none;
        white-space:nowrap;
    }
    /* 画布外框尺寸标签 */
    .canvas-label{
        position:absolute;
        font-size:12px;
        background:rgba(0,0,0,.8);
        color:#fff;
        padding:2px 4px;
        border-radius:2px;
        pointer-events:none;
        white-space:nowrap;
        z-index:20;
    }
    
    /* 选择菜单 */
    .selection-menu{
        position:fixed;
        top:50%;
        left:50%;
        transform:translate(-50%,-50%);
        background:#fff;
        border:2px solid #333;
        border-radius:8px;
        padding:20px;
        box-shadow:0 4px 20px rgba(0,0,0,.3);
        z-index:1000;
        display:none;
    }
    .selection-menu h3{
        margin:0 0 15px 0;
        color:#333;
        text-align:center;
    }
    .selection-menu button{
        display:block;
        width:200px;
        margin:10px 0;
        padding:12px;
        border:1px solid #ddd;
        border-radius:4px;
        background:#f8f9fa;
        cursor:pointer;
        font-size:14px;
        transition:all .2s;
    }
    .selection-menu button:hover{
        background:#e9ecef;
        border-color:#adb5bd;
    }
    .selection-menu button:active{
        background:#dee2e6;
    }
    /* 零件矩形 */
    .part-rectangle{
        position:absolute;
        background:rgba(128,128,128,0.6);
        border:2px solid #666;
        cursor:move;
        user-select:none;
        box-sizing:border-box; /* 保证宽高包含边框，避免 41×31mm */
    }
    /* 零件调整手柄 */
    .resize-handle{
        position:absolute;
        width:8px;
        height:8px;
        background:#fff;
        border:1px solid #333;
        cursor:pointer;
    }
    .resize-handle.nw{top:-4px;left:-4px;cursor:nw-resize;}
    .resize-handle.ne{top:-4px;right:-4px;cursor:ne-resize;}
    .resize-handle.sw{bottom:-4px;left:-4px;cursor:sw-resize;}
    .resize-handle.se{bottom:-4px;right:-4px;cursor:se-resize;}
    /* 边缘拖拽手柄（用于零件与孔位组） */
    .edge-handle{
        position:absolute;
        width:2px;
        height:2px;
        background:#fff;
        border:1px solid #333;
        border-radius:2px;
        cursor:pointer;
        z-index:12;
    }
    .edge-handle.n{top:-5px;left:50%;transform:translateX(-50%);cursor:n-resize;}
    .edge-handle.s{bottom:-5px;left:50%;transform:translateX(-50%);cursor:s-resize;}
    .edge-handle.w{left:-5px;top:50%;transform:translateY(-50%);cursor:w-resize;}
    .edge-handle.e{right:-5px;top:50%;transform:translateY(-50%);cursor:e-resize;}

    /* 工具栏 */
    .toolbar{
        position:absolute;
        top:6px;
        left:6px;
        z-index:2000;
        display:flex;
        gap:6px;
    }
    .toolbar button{
        padding:4px 8px;
        font-size:12px;
        border:1px solid #bbb;
        border-radius:4px;
        background:#fff;
        cursor:pointer;
    }
    .toolbar button:hover{background:#f3f3f3}
    /* 长度度量 */
    .measure-line{
        position:absolute;
        pointer-events:none;
        border-top:1px dashed #000;
        transform-origin:left top;
        z-index:11;
    }
    .measure-label{
        position:absolute;
        font-size:10px;
        background:rgba(0,0,0,.75);
        color:#fff;
        padding:1px 3px;
        border-radius:2px;
        pointer-events:none;
        white-space:nowrap;
        z-index:12;
    }
        /* 右键菜单 */
        .context-menu{
        position:fixed;
        background:#fff;
        border:1px solid #ccc;
        border-radius:4px;
        box-shadow:0 2px 10px rgba(0,0,0,.2);
        padding:5px 0;
        z-index:1001;
        display:none;
        min-width:150px;
    }
    .context-menu-item{
        padding:8px 15px;
        cursor:pointer;
        font-size:14px;
        border-bottom:1px solid #eee;
    }
    .context-menu-item:last-child{
        border-bottom:none;
    }
    .context-menu-item:hover{
        background:#f5f5f5;
    }

</style>
</head>
<body>
<div class="wrapper">
    <div class="canvas" id="canvas"></div>
</div>

<!-- 选择菜单 -->
<div class="selection-menu" id="selectionMenu">
    <h3>选择创建类型</h3>
    <button onclick="createHoleGroupFromMenu()">一组孔位（4个）</button>
    <button onclick="createPartFromMenu()">一个零件</button>
    <button onclick="closeSelectionMenu()">取消</button>
</div>

<!-- 工具栏：保存/加载 -->
<div class="toolbar">
    <button id="btnSaveFile">保存到文件</button>
    <button id="btnLoadFile">从文件加载</button>
    <input id="fileLoader" type="file" accept="application/json" style="display:none" />
    <span id="saveHint" style="font-size:11px;color:#666;align-self:center"></span>
    
    <button id="btnClearAutosave">清除自动保存</button>
    <button id="btnRestoreAutosave">恢复自动保存</button>
 </div>

<!-- 右键菜单 -->
<div class="context-menu" id="contextMenu">
    <div class="context-menu-item" onclick="createHoleGroupFromContext()">创建孔位组</div>
    <div class="context-menu-item" onclick="createPartFromContext()">创建零件</div>
    <div class="context-menu-item" onclick="startMeasureFromContext()">创建长度度量</div>
</div>

<script>
    /* ---------- 右键菜单管理 ---------- */
function showContextMenu(e) {
    e.preventDefault(); // 阻止默认右键菜单
    
    const rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    x = Math.round(x / grid) * grid;
    y = Math.round(y / grid) * grid;
    
    pendingPosition = {x, y};
    
    const contextMenu = document.getElementById('contextMenu');
    contextMenu.style.display = 'block';
    contextMenu.style.left = e.clientX + 'px';
    contextMenu.style.top = e.clientY + 'px';
}

function hideContextMenu() {
    document.getElementById('contextMenu').style.display = 'none';
}

function createHoleGroupFromContext() {
    if (pendingPosition) {
        const color = colors[(groupId) % colors.length];
        createHoleGroup(pendingPosition.x, pendingPosition.y, color);
        updateCanvasSizeLabels();
        hideContextMenu();
    }
}

function createPartFromContext() {
    if (pendingPosition) {
        createPart(pendingPosition.x, pendingPosition.y);
        updateCanvasSizeLabels();
        hideContextMenu();
    }
}

const canvas   = document.getElementById('canvas');
const wrapper  = document.querySelector('.wrapper');
const mmPerPx = 25.4 / 96;
const grid    = 5 / mmPerPx;          // 5 mm 网格
let groupId   = 0;                    // 组计数
let partId    = 0;                    // 零件计数
let pendingPosition = null;           // 待创建位置
const colors  = ['#e00','#007bff','#28a745','#fd7e14','#6f42c1','#20c997']; // 循环色
const mm = v => Math.round(v * mmPerPx);
let measures = [];
let measureCreating = false;
let pendingMeasureP1 = null;

/* ---------- 持久化：保存/加载 ---------- */
const AUTOSAVE_KEY = 'designer-autosave-v1';
let saveTimer = null;

function scheduleAutosave(){
    if(saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(()=>{
        const data = serializeState();
        try{
            localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(data));
            const hint = document.getElementById('saveHint');
            if(hint){ hint.textContent = '已自动保存'; setTimeout(()=>{hint.textContent='';}, 1200); }
        }catch(err){ /* ignore quota errors */ }
    }, 300);
}

function serializeState(){
    const groups = Array.from(canvas.querySelectorAll('.hole-group')).map(group=>{
        const holes = Array.from(group.querySelectorAll('.m3-hole')).map(h=>({
            x: h.offsetLeft,
            y: h.offsetTop
        }));
        return { color: group.dataset.color || '#000', holes };
    });
    const parts = Array.from(canvas.querySelectorAll('.part-rectangle')).map(p=>({
        left: p.offsetLeft,
        top: p.offsetTop,
        width: p.offsetWidth,
        height: p.offsetHeight
    }));
    return { groups, parts, measures };
}

function clearCanvas(){
    Array.from(canvas.children).forEach(ch=>ch.remove());
}

function loadState(data){
    clearCanvas();
    groupId = 0; partId = 0; measures = [];
    if(data && Array.isArray(data.groups)){
        data.groups.forEach(g=>{
            // 创建占位组，再精确设置孔位坐标
            if(g.holes && g.holes[0]){
                const color = g.color || colors[(groupId)%colors.length];
                createHoleGroup(g.holes[0].x, g.holes[0].y, color);
                const group = canvas.lastElementChild;
                const holes = Array.from(group.querySelectorAll('.m3-hole'));
                g.holes.slice(0,4).forEach((pt, idx)=>{
                    if(holes[idx]){
                        holes[idx].style.left = pt.x + 'px';
                        holes[idx].style.top  = pt.y + 'px';
                    }
                });
                updateGroup(group);
            }
        });
    }
    if(data && Array.isArray(data.parts)){
        data.parts.forEach(p=>{
            createPart(p.left, p.top);
            const el = canvas.querySelector('.part-rectangle:last-of-type');
            if(el){
                el.style.width = p.width + 'px';
                el.style.height = p.height + 'px';
                updatePartCenterLabel(el);
            }
        });
    }
    if(data && Array.isArray(data.measures)){
        data.measures.forEach(m=>{
            if(m && m.p1 && m.p2){ createMeasure(m.p1.x, m.p1.y, m.p2.x, m.p2.y); }
        });
    }
}

function exportToFile(){
    const data = serializeState();
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    const now = new Date();
    const ts = now.getFullYear()+
        String(now.getMonth()+1).padStart(2,'0')+
        String(now.getDate()).padStart(2,'0')+'-'+
        String(now.getHours()).padStart(2,'0')+
        String(now.getMinutes()).padStart(2,'0')+
        String(now.getSeconds()).padStart(2,'0');
    a.download = `design-${ts}.json`;
    a.href = URL.createObjectURL(blob);
    a.click();
    URL.revokeObjectURL(a.href);
}

function importFromFile(file){
    const reader = new FileReader();
    reader.onload = () => {
        try{
            const data = JSON.parse(reader.result);
            loadState(data);
            scheduleAutosave();
        }catch(err){ alert('文件格式不正确'); }
    };
    reader.readAsText(file);
}

/* ---------- 外框尺寸标签 ---------- */
function updateCanvasSizeLabels(){
    // 移除任何位置的旧标签（无论在 wrapper 还是 canvas 内）
    document.querySelectorAll('.canvas-label').forEach(el=>el.remove());

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const wmm = mm(w);
    const hmm = mm(h);

    const canvasLeft = canvas.offsetLeft;
    const canvasTop  = canvas.offsetTop;

    const topLab = document.createElement('div');
    topLab.className = 'canvas-label';
    topLab.textContent = wmm + ' mm';
    topLab.style.left = (canvasLeft + w / 2) + 'px';
    topLab.style.top = (canvasTop - 8) + 'px';
    topLab.style.transform = 'translateX(-50%)';
    wrapper.appendChild(topLab);

    const rightLab = document.createElement('div');
    rightLab.className = 'canvas-label';
    rightLab.textContent = hmm + ' mm';
    rightLab.style.left = (canvasLeft + w + 8) + 'px';
    rightLab.style.top = (canvasTop + h / 2) + 'px';
    rightLab.style.transform = 'translateY(-50%) rotate(-90deg)';
    wrapper.appendChild(rightLab);
}

/* ---------- 创建一组四孔位矩形 ---------- */
function createHoleGroup(x0,y0,color){
    const gid   = ++groupId;
    const group = document.createElement('div');
    group.className = 'hole-group';
    group.id = 'g'+gid;
    group.dataset.color = color;
    canvas.appendChild(group);

    /* 初始 4 个孔位（顺时针，边长为 20 mm，5 mm 的整数倍） */
    const step = 4 * grid; // 4 * 5mm = 20mm
    const pts = [
        {x:x0,           y:y0},
        {x:x0+step,      y:y0},
        {x:x0+step,      y:y0+step},
        {x:x0,           y:y0+step}
    ];
    pts.forEach((p,i)=>{
        const h = document.createElement('div');
        h.className = 'm3-hole';
        h.style.left = p.x + 'px';
        h.style.top  = p.y + 'px';
        h.style.backgroundColor = color;
        h.textContent = 'M3';
        h.dataset.idx = i;
        group.appendChild(h);
    });

    updateGroup(group);
    enableDrag(group);
    scheduleAutosave();
}

/* ---------- 更新连线、标签 ---------- */
function updateGroup(group){
    const holes = Array.from(group.children);
    const holeNodes = holes.filter(h=>h.classList.contains('m3-hole'));
    const pts   = holeNodes.map(h=>({x:h.offsetLeft,y:h.offsetTop, el:h}));

    /* 移除旧元素 */
    group.querySelectorAll('.edge,.edge-label,.edge-handle').forEach(el=>el.remove());

    /* 边与标签 */
    for(let i=0;i<4;i++){
        const p1 = pts[i], p2 = pts[(i+1)%4];
        const len = mm(Math.hypot(p2.x-p1.x,p2.y-p1.y));
        const midX=(p1.x+p2.x)/2, midY=(p1.y+p2.y)/2;
        const ang=Math.atan2(p2.y-p1.y,p2.x-p1.x);

        const edge = document.createElement('div');
        edge.className='edge';
        edge.style.left=p1.x+'px'; edge.style.top=p1.y+'px';
        edge.style.width=Math.hypot(p2.x-p1.x,p2.y-p1.y)+'px';
        edge.style.transform=`rotate(${ang}rad)`;
        edge.style.borderColor=group.dataset.color;
        group.appendChild(edge);

        const lab = document.createElement('div');
        lab.className='edge-label';
        lab.textContent=len+' mm';
        lab.style.left=midX+'px'; lab.style.top=midY+'px';
        group.appendChild(lab);
    }

    // 计算当前矩形边界（假定四孔为矩形四角）
    const minX = Math.min(...pts.map(p=>p.x));
    const maxX = Math.max(...pts.map(p=>p.x));
    const minY = Math.min(...pts.map(p=>p.y));
    const maxY = Math.max(...pts.map(p=>p.y));

    // 在四边添加边缘手柄
    const addEdgeHandle = (dir, left, top) => {
        const eh = document.createElement('div');
        eh.className = `edge-handle ${dir}`;
        eh.style.left = left + 'px';
        eh.style.top = top + 'px';
        group.appendChild(eh);

        let active=false, startX=0, startY=0, sMinX=minX, sMaxX=maxX, sMinY=minY, sMaxY=maxY;
        eh.addEventListener('mousedown', e=>{
            active=true; e.stopPropagation();
            startX = e.clientX; startY = e.clientY;
            sMinX = minX; sMaxX = maxX; sMinY = minY; sMaxY = maxY;
        });
        window.addEventListener('mousemove', e=>{
            if(!active) return;
            const dx = Math.round((e.clientX - startX) / grid) * grid;
            const dy = Math.round((e.clientY - startY) / grid) * grid;

            let nMinX = sMinX, nMaxX = sMaxX, nMinY = sMinY, nMaxY = sMaxY;
            if(dir==='e') nMaxX = Math.min(canvas.clientWidth, sMaxX + dx);
            if(dir==='w') nMinX = Math.max(0, sMinX + dx);
            if(dir==='s') nMaxY = Math.min(canvas.clientHeight, sMaxY + dy);
            if(dir==='n') nMinY = Math.max(0, sMinY + dy);

            // 更新四个角孔位，保持矩形
            const tl = {x:nMinX, y:nMinY};
            const tr = {x:nMaxX, y:nMinY};
            const br = {x:nMaxX, y:nMaxY};
            const bl = {x:nMinX, y:nMaxY};

            if(holeNodes.length===4){
                holeNodes[0].style.left = tl.x + 'px';
                holeNodes[0].style.top  = tl.y + 'px';
                holeNodes[1].style.left = tr.x + 'px';
                holeNodes[1].style.top  = tr.y + 'px';
                holeNodes[2].style.left = br.x + 'px';
                holeNodes[2].style.top  = br.y + 'px';
                holeNodes[3].style.left = bl.x + 'px';
                holeNodes[3].style.top  = bl.y + 'px';
            }
            updateGroup(group);
            scheduleAutosave();
        });
        window.addEventListener('mouseup', ()=> active=false);
    };

    addEdgeHandle('n', (minX+maxX)/2, minY);
    addEdgeHandle('e', maxX, (minY+maxY)/2);
    addEdgeHandle('s', (minX+maxX)/2, maxY);
    addEdgeHandle('w', minX, (minY+maxY)/2);
}

/* ---------- 单孔拖拽 ---------- */
function enableDrag(group){
    const holes = Array.from(group.querySelectorAll('.m3-hole'));

    holes.forEach(hole=>{
        let active = false, ox=0, oy=0;
        hole.addEventListener('mousedown', e=>{
            active = true;
            e.stopPropagation();          // 防止触发整组事件
            const rect = canvas.getBoundingClientRect();
            ox = e.clientX - rect.left - hole.offsetLeft;
            oy = e.clientY - rect.top  - hole.offsetTop;
        });

        hole.addEventListener('dblclick', e=>{
            e.stopPropagation();
            const groupEl = hole.closest('.hole-group');
            if(groupEl && confirm('Confirm to delete this group？')){
                groupEl.remove();
                scheduleAutosave();
            }
        });

        window.addEventListener('mousemove', e=>{
            if(!active) return;
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left - ox;
            let y = e.clientY - rect.top  - oy;

            x = Math.max(0, Math.min(x, rect.width));
            y = Math.max(0, Math.min(y, rect.height));

            x = Math.round(x / grid) * grid;
            y = Math.round(y / grid) * grid;

            hole.style.left = x + 'px';
            hole.style.top  = y + 'px';
            updateGroup(group);           // 重新画线
            scheduleAutosave();
        });

        window.addEventListener('mouseup', ()=> active = false);
    });
}

/* ---------- 选择菜单管理 ---------- */
function showSelectionMenu(x, y) {
    pendingPosition = {x, y};
    document.getElementById('selectionMenu').style.display = 'block';
}

function closeSelectionMenu() {
    document.getElementById('selectionMenu').style.display = 'none';
    pendingPosition = null;
}

function createHoleGroupFromMenu() {
    if (pendingPosition) {
        const color = colors[(groupId) % colors.length];
        createHoleGroup(pendingPosition.x, pendingPosition.y, color);
        updateCanvasSizeLabels();
        closeSelectionMenu();
    }
}

function createPartFromMenu() {
    if (pendingPosition) {
        createPart(pendingPosition.x, pendingPosition.y);
        updateCanvasSizeLabels();
        closeSelectionMenu();
    }
}

/* ---------- 创建零件 ---------- */
function createPart(x0, y0) {
    const pid = ++partId;
    const part = document.createElement('div');
    part.className = 'part-rectangle';
    part.id = 'p' + pid;
    part.style.left = x0 + 'px';
    part.style.top = y0 + 'px';
    // 默认尺寸为 40 mm × 30 mm（5 mm 的整数倍）
    part.style.width = (8 * grid) + 'px';   // 8 * 5mm = 40mm
    part.style.height = (6 * grid) + 'px';  // 6 * 5mm = 30mm
    canvas.appendChild(part);

    // 添加调整手柄
    const handles = ['nw', 'ne', 'sw', 'se'];
    handles.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        part.appendChild(handle);
    });

    // 边缘手柄（上右下左）
    const edgeDirs = ['n','e','s','w'];
    edgeDirs.forEach(dir=>{
        const eh = document.createElement('div');
        eh.className = `edge-handle ${dir}`;
        part.appendChild(eh);
    });

    enablePartDrag(part);
    enablePartResize(part);
    updatePartCenterLabel(part); // 初始显示中心尺寸标签
    scheduleAutosave();
}

/* ---------- 更新零件中心尺寸标签 ---------- */
function updatePartCenterLabel(part) {
    // 移除旧的尺寸标签
    part.querySelectorAll('.part-center-label').forEach(el => el.remove());
    
    const width = part.offsetWidth;
    const height = part.offsetHeight;
    
    // 创建中心标签
    const label = document.createElement('div');
    label.className = 'part-center-label';
    label.textContent = `${mm(width)} × ${mm(height)} mm`;
    
    // 居中定位
    label.style.left = '50%';
    label.style.top = '50%';
    label.style.transform = 'translate(-50%, -50%)';
    
    part.appendChild(label);
}

/* ---------- 零件拖拽 ---------- */
function enablePartDrag(part) {
    let active = false, ox = 0, oy = 0;
    
    part.addEventListener('mousedown', e => {
        if (e.target.classList.contains('resize-handle')) return;
        active = true;
        e.stopPropagation();
        const rect = canvas.getBoundingClientRect();
        ox = e.clientX - rect.left - part.offsetLeft;
        oy = e.clientY - rect.top - part.offsetTop;
    });

    window.addEventListener('mousemove', e => {
        if (!active) return;
        const rect = canvas.getBoundingClientRect();
        let x = e.clientX - rect.left - ox;
        let y = e.clientY - rect.top - oy;

        x = Math.max(0, Math.min(x, rect.width - part.offsetWidth));
        y = Math.max(0, Math.min(y, rect.height - part.offsetHeight));

        x = Math.round(x / grid) * grid;
        y = Math.round(y / grid) * grid;

        part.style.left = x + 'px';
        part.style.top = y + 'px';
        updatePartCenterLabel(part); // 拖拽时更新标签位置
        scheduleAutosave();
    });

    window.addEventListener('mouseup', () => active = false);
}

/* ---------- 零件大小调整 ---------- */
function enablePartResize(part) {
    const handles = part.querySelectorAll('.resize-handle');
    
    handles.forEach(handle => {
        let active = false, startX = 0, startY = 0, startWidth = 0, startHeight = 0, startLeft = 0, startTop = 0;
        
        handle.addEventListener('mousedown', e => {
            active = true;
            e.stopPropagation();
            const rect = canvas.getBoundingClientRect();
            startX = e.clientX;
            startY = e.clientY;
            startWidth = part.offsetWidth;
            startHeight = part.offsetHeight;
            startLeft = part.offsetLeft;
            startTop = part.offsetTop;
        });

        window.addEventListener('mousemove', e => {
            if (!active) return;
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            let newWidth = startWidth;
            let newHeight = startHeight;
            let newLeft = startLeft;
            let newTop = startTop;

            if (handle.classList.contains('se')) {
                newWidth = Math.max(20, startWidth + deltaX);
                newHeight = Math.max(20, startHeight + deltaY);
            } else if (handle.classList.contains('sw')) {
                newWidth = Math.max(20, startWidth - deltaX);
                newHeight = Math.max(20, startHeight + deltaY);
                newLeft = startLeft + startWidth - newWidth;
            } else if (handle.classList.contains('ne')) {
                newWidth = Math.max(20, startWidth + deltaX);
                newHeight = Math.max(20, startHeight - deltaY);
                newTop = startTop + startHeight - newHeight;
            } else if (handle.classList.contains('nw')) {
                newWidth = Math.max(20, startWidth - deltaX);
                newHeight = Math.max(20, startHeight - deltaY);
                newLeft = startLeft + startWidth - newWidth;
                newTop = startTop + startHeight - newHeight;
            } else if (handle.classList.contains('edge-handle')) {
                // 边缘手柄：n/e/s/w
                if (handle.classList.contains('e')) {
                    newWidth = Math.max(20, startWidth + deltaX);
                } else if (handle.classList.contains('w')) {
                    newWidth = Math.max(20, startWidth - deltaX);
                    newLeft = startLeft + startWidth - newWidth;
                } else if (handle.classList.contains('s')) {
                    newHeight = Math.max(20, startHeight + deltaY);
                } else if (handle.classList.contains('n')) {
                    newHeight = Math.max(20, startHeight - deltaY);
                    newTop = startTop + startHeight - newHeight;
                }
            }

            // 网格对齐
            newWidth = Math.round(newWidth / grid) * grid;
            newHeight = Math.round(newHeight / grid) * grid;
            newLeft = Math.round(newLeft / grid) * grid;
            newTop = Math.round(newTop / grid) * grid;

            // 边界检查
            if (newLeft < 0) newLeft = 0;
            if (newTop < 0) newTop = 0;
            if (newLeft + newWidth > canvas.offsetWidth) newWidth = canvas.offsetWidth - newLeft;
            if (newTop + newHeight > canvas.offsetHeight) newHeight = canvas.offsetHeight - newTop;

            part.style.width = newWidth + 'px';
            part.style.height = newHeight + 'px';
            part.style.left = newLeft + 'px';
            part.style.top = newTop + 'px';
            
            updatePartCenterLabel(part); // 调整大小时更新标签
            scheduleAutosave();
        });

        window.addEventListener('mouseup', () => active = false);
    });
}

/* ---------- 长度度量 ---------- */
function createMeasure(x1,y1,x2,y2){
    // 保存数据
    const m = { p1:{x:x1,y:y1}, p2:{x:x2,y:y2} };
    measures.push(m);

    // DOM 展示
    const lenPx = Math.hypot(x2-x1, y2-y1);
    const ang = Math.atan2(y2-y1, x2-x1);
    const midX = (x1+x2)/2, midY = (y1+y2)/2;

    const line = document.createElement('div');
    line.className = 'measure-line';
    line.style.left = x1 + 'px';
    line.style.top = y1 + 'px';
    line.style.width = lenPx + 'px';
    line.style.transform = `rotate(${ang}rad)`;
    canvas.appendChild(line);

    const label = document.createElement('div');
    label.className = 'measure-label';
    label.textContent = mm(lenPx) + ' mm';
    label.style.left = midX + 'px';
    label.style.top = midY + 'px';
    canvas.appendChild(label);

    scheduleAutosave();
}

function startMeasureFromContext(){
    hideContextMenu();
    // 使用 pendingPosition 作为第一个点
    if(!pendingPosition) return;
    measureCreating = true;
    pendingMeasureP1 = {x: pendingPosition.x, y: pendingPosition.y};
}

canvas.addEventListener('click', (e)=>{
    if(!measureCreating) return;
    const rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    x = Math.round(x / grid) * grid;
    y = Math.round(y / grid) * grid;
    if(!pendingMeasureP1){
        pendingMeasureP1 = {x,y};
    }else{
        createMeasure(pendingMeasureP1.x, pendingMeasureP1.y, x, y);
        measureCreating = false;
        pendingMeasureP1 = null;
    }
}, true);

document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape' && measureCreating){
        measureCreating = false;
        pendingMeasureP1 = null;
    }
});

/* ---------- 右键新建 ---------- */
canvas.addEventListener('contextmenu', e => {
    const rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;
    x = Math.round(x / grid) * grid;
    y = Math.round(y / grid) * grid;
    e.preventDefault();
    showSelectionMenu(x, y);
});

// 工具栏事件
document.getElementById('btnSaveFile').addEventListener('click', exportToFile);
document.getElementById('btnLoadFile').addEventListener('click', ()=> document.getElementById('fileLoader').click());
document.getElementById('fileLoader').addEventListener('change', (e)=>{
    const file = e.target.files && e.target.files[0];
    if(file) importFromFile(file);
    e.target.value = '';
});
document.getElementById('btnClearAutosave').addEventListener('click', ()=>{
    localStorage.removeItem(AUTOSAVE_KEY);
    alert('已清除自动保存');
});
document.getElementById('btnRestoreAutosave').addEventListener('click', ()=>{
    const raw = localStorage.getItem(AUTOSAVE_KEY);
    if(!raw){ alert('没有可恢复的自动保存'); return; }
    try{ loadState(JSON.parse(raw)); }catch{ alert('自动保存数据损坏'); }
});

/* ---------- 初始示例组（位置对齐到 5 mm 网格） ---------- */
createHoleGroup(2*grid,2*grid,colors[0]);
updateCanvasSizeLabels();
window.addEventListener('resize', updateCanvasSizeLabels);

// 首次加载尝试恢复自动保存
try{
    const raw = localStorage.getItem(AUTOSAVE_KEY);
    if(raw){ loadState(JSON.parse(raw)); }
}catch{}
</script>
</body>
</html>